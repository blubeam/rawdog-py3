The objective here is to significantly reduce rawdog's memory usage in favour
of IO. (Although the IO usage may actually go down, since we don't have to
rewrite feed states that didn't change.)

The plan is to enable split state while keeping regular behaviour around as the
default (for now, to be removed in rawdog 3).

-- Stage 1: making update memory usage O(biggest #articles) --

Feed stays as is -- i.e. persisted as part of Rawdog, containing the feed info,
and so forth. (These may change in rawdog 3 -- there's a tradeoff, because if
we store the update time/eTag/... in the feed state then we have to rewrite it
every time we update, rather than just if the content's changed. Actually, we
don't want to do this, since we don't want to read the FeedState at all if it
doesn't need updating.)

There's a new FeedState class, persisted into STATEDIR/feeds/12345678.state
(where 12345678 is the feed URL hash as currently used).
(FIXME: when changing feed URL, we need to rename the statefile too.)

Feed.update() takes an article-dict argument, which might be the existing
Rawdog.articles hash or might be from a FeedState, just containing that feed's
articles. (It doesn't care either way.)

When doing updates, if we're in split-state mode, it loads and saves the
FeedState around each article.

(FIXME: optimisation: only mark a FeedState as modified if it was actually
modified, not if it was updated but nothing changed.)

-- Stage 2: making write memory usage O(#articles on page) --

Article gets a new method to return the date that should be used for sorting
(i.e. this logic gets moved out of the write code).

Feed gets a new method which returns the list of articles eligable for output
-- as (sort-date, feed-hash, sequence-number, article-hash) tuples (for ease of
sorting).

Feed gets a new method which returns the Article objects for a list of article
hashes. (This should be sufficiently abstract to let us do this over a database
at some point in the future...)

Rawdog.write() then collects the list of articles from all the feeds, sorts it,
and retrieves only the appropriate set of articles from each feed state before
writing them.
(FIXME: optimisation: if we're updating all feeds, collect the list then to
avoid having to read all the statefiles.)
(FIXME: or alternately, just stash this in the Feed at update time.)
(FIXME: the sort hook will need to be changed -- use a different hook when in
split-state mode.)
