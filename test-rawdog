#!/bin/sh
# test-rawdog: run some basic tests to make sure rawdog's working.
# Copyright 2013 Adam Sampson <ats@offog.org>
#
# rawdog is free software; you can redistribute and/or modify it
# under the terms of that license as published by the Free Software
# Foundation; either version 2 of the License, or (at your option)
# any later version.
#
# rawdog is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with rawdog; see the file COPYING. If not, write to the Free
# Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA 02110-1301, USA, or see http://www.gnu.org/.

# Default to the C locale, to avoid localised error messages.
default_LC_ALL="C"

# Try to find generic UTF-8 and Japanese UTF-8 locales. (They may not be
# installed.)
utf8_LC_ALL="$(locale -a | grep -i 'utf-\?8' | head -1)"
ja_LC_ALL="$(locale -a | grep -i ja_JP.utf\-?8 | head -1)"

# Default to UTC so that local times are reported consistently.
default_TZ="UTC"

statedir="testauto"

# Hostname and ports to run the test server on.
serverhost="localhost"
timeoutport="8431"
httpport="8432"

# Connections to this host should time out.
# (This is distinct from timeoutport above: if you connect to timeoutport, it
# will accept the connection but not do anything, whereas this will timeout
# while connecting.)
timeouthost="81.91.98.19"

# Run tests that are currently known to fail.
knownbad=false

# Keep going when a test fails.
keepgoing=false

httpdir="$statedir/pub"
httpurl="http://$serverhost:$httpport"

# Start the server, and kill it when this script exits.
serverpid=""
trap 'test -n "$serverpid" && kill $serverpid' 0
python testserver.py "$serverhost" "$timeoutport" "$httpport" "$httpdir" &
serverpid="$!"

die () {
	echo "Test failed:" "$@"
	if ! $keepgoing; then
		exit 1
	fi
}

cleanstate () {
	rm -fr $statedir $httpdir
	mkdir -p $statedir $statedir/plugins $httpdir
	cp config $statedir/config

	export LC_ALL="$default_LC_ALL"
	export TZ="$default_TZ"
}

add () {
	echo "$1" >>$statedir/config
}

begin () {
	echo ">>> Testing $1"
	cleanstate
	add "showtracebacks true"
	cmdnum=0
}

equals () {
	if [ "$1" != "$2" ]; then
		die "expected '$1'; got '$2'"
	fi
}

exists () {
	for fn in "$@"; do
		if ! [ -e "$fn" ]; then
			die "expected $fn to exist"
		fi
	done
}

same () {
	exists "$1" "$2"
	if ! cmp "$1" "$2"; then
		die "expected $1 to have the same contents as $2"
	fi
}

contains () {
	file="$1"
	exists "$file"
	shift
	for key in "$@"; do
		if ! grep -q "$key" "$file"; then
			cat "$file"
			die "expected $file to contain '$key'"
		fi
	done
}

not_contains () {
	file="$1"
	exists "$file"
	shift
	for key in "$@"; do
		if grep -q "$key" "$file"; then
			cat "$file"
			die "expected $file not to contain '$key'"
		fi
	done
}

# Run rawdog.
runf () {
	cmdnum=$(expr $cmdnum + 1)
	outfile=$statedir/out$cmdnum
	./rawdog -d $statedir -V log$cmdnum "$@" >$outfile 2>&1
}

# Run rawdog, expecting it to exit 0.
run () {
	if ! runf "$@"; then
		cat $outfile
		die "exited non-0"
	fi
}

# Run rawdog, expecting it to exit non-0.
runn () {
	if runf "$@"; then
		cat $outfile
		die "exited 0"
	fi
}

# Run rawdog, expecting no complaints.
runs () {
	run "$@"
	if [ -s $outfile ]; then
		cat $outfile
		die "expected no output"
	fi
}

# Run rawdog, expecting a complaint containing the first arg.
rune () {
	key="$1"
	shift
	run "$@"
	contains $outfile "$key"
}

# Run rawdog, expecting it to exit non-0 with a complaint containing the first
# arg.
runne () {
	key="$1"
	shift
	runn "$@"
	contains $outfile "$key"
}

make_text () {
	cat >"$1" <<EOF
This is manifestly not a feed.
EOF
}

make_html () {
	cat >"$1" <<EOF
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
            "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <title>Not a feed</title>
</head>
<body>
  <p>This is manifestly not a feed.</p>
</body>
</html>
EOF
}

make_html_head () {
	cat >"$1" <<EOF
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
            "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <title>Not a feed</title>
EOF
	cat >>"$1"
	cat >>"$1" <<EOF
</head>
<body>
  <p>This is manifestly not a feed.</p>
</body>
</html>
EOF
}

make_html_body () {
	cat >"$1" <<EOF
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
            "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <title>Not a feed</title>
</head>
<body>
  <p>This is manifestly not a feed.</p>
EOF
	cat >>"$1"
	cat >>"$1" <<EOF
</body>
</html>
EOF
}

make_rss20 () {
	cat >"$1" <<EOF
<rss version="2.0">
  <channel>
    <title>example-feed-title</title>
    <link>http://example.org/</link>
    <description>example-feed-description</description>
    <item>
      <title>example-item-title</title>
      <link>http://example.org/item</link>
      <description><![CDATA[<p>example-item-description</p>]]></description>
    </item>
  </channel>
</rss>
EOF
}

make_rss20_desc () {
	cat >"$1" <<EOF
<rss version="2.0">
  <channel>
    <title>example-feed-title</title>
    <link>http://example.org/</link>
    <description>example-feed-description</description>
    <item>
      <title>example-item-title</title>
      <link>http://example.org/item</link>
      <description>
EOF
	cat >>"$1"
	cat >>"$1" <<EOF
      </description>
    </item>
  </channel>
</rss>
EOF
}

write_desc () {
	make_rss20_desc $httpdir/feed.rss
	add "feed 0 $httpurl/feed.rss"
	runs -uw
}

make_atom10 () {
	cat >"$1" <<EOF
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>example-feed-title</title>
  <link href="http://example.org/"/>
  <updated>2013-01-01T18:00:00Z</updated>
  <author>
    <name>example-feed-author</name>
  </author>
  <id>http://example.org/feed-id</id>
  <entry>
    <title>example-item-title</title>
    <link href="http://example.org/item"/>
    <id>http://example.org/item-id</id>
    <updated>2013-01-01T18:00:00Z</updated>
    <summary>example-item-description</summary>
  </entry>
</feed>
EOF
}

make_single () {
	cat >"$1" <<EOF
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>example-feed-title</title>
  <link href="http://example.org/"/>
  <updated>2013-01-01T18:00:00Z</updated>
  <author>
    <name>example-feed-author</name>
  </author>
  <id>http://example.org/feed-id</id>
  <entry>
    <title>$2-title</title>
    <link href="$3"/>
    <id>$4</id>
    <updated>2013-01-01T18:00:00Z</updated>
    <summary>$2-description</summary>
  </entry>
</feed>
EOF
}

make_range () {
	from="$1"
	to="$2"
	file="$3"
	cat >"$file" <<EOF
<rss version="2.0">
  <channel>
    <title>example-feed-title</title>
    <link>http://example.org/</link>
    <description>example-feed-description</description>
EOF
	for i in $(seq $from $to); do
		cat >>"$file" <<EOF
    <item>
      <title>range-title-$i-</title>
      <link>http://example.org/item$i</link>
      <description><![CDATA[<p>range-description-$i</p>]]></description>
    </item>
EOF
	done
	cat >>"$file" <<EOF
  </channel>
</rss>
EOF
}

make_n () {
	make_range 1 "$@"
}

range () {
	seq -f "range-title-%.f-" $1 $2
}

output_range () {
	contains $statedir/output.html $(range $1 $2)
}

not_output_range () {
	not_contains $statedir/output.html $(range $1 $2)
}

output_n () {
	output_range 1 "$@"
}

begin "help"
run --help

begin "bad config syntax"
add "foo"
rune "Bad line in config"

begin "bad config directive"
add "foo bar"
rune "Unknown config command"

begin "empty config file"
: >$statedir/config
runs -uw

begin "corrupt state file"
echo this is not a valid state file >$statedir/state
runne "means the file is corrupt" -u

begin "empty state file"
touch $statedir/state
runne "means the file is corrupt" -u

begin "corrupt splitstate file"
make_rss20 $statedir/simple.rss
add "splitstate true"
add "feed 0 simple.rss"
runs -u
echo this is not a valid state file >$(echo $statedir/feeds/*.state)
runne "means the file is corrupt" -u

for run in first second feed-adding; do
	for state in false true; do
		begin "recover from crash on $run run, splitstate $state"
		make_rss20 $statedir/0.rss
		add "splitstate $state"
		add "feed 0 0.rss"
		if [ "$run" != first ]; then
			runs -u
		fi
		if [ "$run" = feed-adding ]; then
			make_rss20 $statedir/1.rss
			add "feed 0 1.rss"
		fi
		# Crash while updating, so we have both state files open.
		cat >$statedir/plugins/crash.py <<EOF
import rawdoglib.plugins
def crash(*args):
    raise Exception("deliberate")
rawdoglib.plugins.attach_hook("post_update_feed", crash)
EOF
		runne "Exception: deliberate" -u
		rm $statedir/plugins/crash.py
		runs -u
	done
done

begin "filename"
make_rss20 $statedir/simple.rss
add "feed 0 simple.rss"
runs -u

begin "filename not found"
add "feed 0 missing.rss"
rune "No such file" -u

begin "file: URL"
make_rss20 $statedir/simple.rss
add "feed 0 file:simple.rss"
runs -u

begin "file: URL not found"
add "feed 0 file:missing.rss"
rune "No such file" -u

begin "http: URL and write, RSS 2.0"
make_rss20 $httpdir/simple.rss
add "feed 0 $httpurl/simple.rss"
runs -uw
contains $statedir/output.html example-item-title example-item-description

begin "http: URL and write, RSS 2.0, empty config"
make_rss20 $httpdir/simple.rss
rm $statedir/config
add "feed 0 $httpurl/simple.rss"
runs -uw
contains $statedir/output.html example-item-title example-item-description

begin "http: URL and write, Atom 1.0"
make_atom10 $httpdir/simple.atom
add "feed 0 $httpurl/simple.atom"
runs -uw
contains $statedir/output.html example-item-title example-item-description

begin "HTML rather than a feed"
make_html $httpdir/bad.html
add "feed 0 $httpurl/bad.html"
rune "could not be understood" -u

begin "plain text rather than a feed"
make_text $httpdir/bad.txt
add "feed 0 $httpurl/bad.txt"
rune "could not be understood" -u

for code in 301 302; do
	begin "HTTP $code redirect to HTML"
	make_html $httpdir/bad.html
	add "changeconfig false"
	add "feed 0 $httpurl/$code/bad.html"
	rune "could not be understood" -u

	begin "HTTP $code redirect to plain text"
	make_text $httpdir/bad.txt
	add "changeconfig false"
	add "feed 0 $httpurl/$code/bad.txt"
	rune "could not be understood" -u

	begin "HTTP $code redirect to 404"
	add "changeconfig false"
	add "feed 0 $httpurl/$code/404"
	rune "404" -u
done

begin "empty file rather than a feed"
touch $httpdir/bad.xml
add "feed 0 $httpurl/bad.xml"
rune "could not be understood" -u

begin "valid feed with no items"
cat >$httpdir/empty.xml <<EOF
<rss version="2.0">
  <channel>
    <title>example-feed-title</title>
    <link>http://example.org/</link>
    <description>example-feed-description</description>
  </channel>
</rss>
EOF
add "feed 0 $httpurl/empty.xml"
runs -u

begin "HTTP 404"
add "feed 0 $httpurl/notthere"
rune "404" -u

for proto in http https ftp; do
	begin "$proto: connect timeout"
	add "timeout 1s"
	add "feed 0 $proto://$timeouthost/feed.xml"
	rune "Timeout while reading" -u

	begin "$proto: response timeout"
	add "timeout 1s"
	add "feed 0 $proto://$serverhost:$timeoutport/feed.xml"
	rune "Timeout while reading" -u
done

begin "ignoretimeouts true"
add "timeout 1s"
add "ignoretimeouts true"
add "feed 0 http://$serverhost:$timeoutport/feed.xml"
runs -u

begin "0 period"
make_rss20 $httpdir/simple.rss
add "feed 0 $httpurl/simple.rss"
runs -u
rm $httpdir/simple.rss
rune "404" -u

begin "1h period"
make_rss20 $httpdir/simple.rss
add "feed 1h $httpurl/simple.rss"
runs -u
rm $httpdir/simple.rss
runs -u

begin "10 items"
make_n 10 $httpdir/feed.rss
add "feed 0 $httpurl/feed.rss"
runs -uw
output_n 10

begin "new articles are collected"
make_n 3 $httpdir/feed.rss
add "feed 0 $httpurl/feed.rss"
runs -uw
output_n 3
make_n 6 $httpdir/feed.rss
runs -uw
output_n 6

begin "maxarticles 10"
make_n 20 $httpdir/feed.rss
add "maxarticles 10"
add "feed 0 $httpurl/feed.rss"
runs -uw
output_n 10
not_output_range 11 20

begin "keepmin 10"
make_n 20 $httpdir/feed.rss
add "keepmin 10"
add "expireage 0"
add "feed 0 $httpurl/feed.rss"
runs -uw
output_n 20
make_n 5 $httpdir/feed.rss
runs -uw
# Should have the 5 currently in the feed, and 10 in total
output_n 5
if [ $(grep range-title- $statedir/output.html | wc -l) != 10 ]; then
	die "Should contain 10 items"
fi

begin "currentonly true"
make_n 10 $httpdir/feed.rss
add "currentonly true"
add "feed 0 $httpurl/feed.rss"
runs -uw
output_n 10
make_n 5 $httpdir/feed.rss
runs -uw
output_n 5
not_output_range 6 10

dupecheck () {
	add "useids false"
	add "feed 0 $httpurl/feed.atom"
	make_single $httpdir/feed.atom item-a \
		http://example.org/link/x http://example.org/id/0
	runs -u
	make_single $httpdir/feed.atom item-b \
		http://example.org/link/x http://example.org/id/1
	runs -u
	make_single $httpdir/feed.atom item-c \
		http://example.org/link/y http://example.org/id/1
	runs -uw
}

begin "hideduplicates none"
add "hideduplicates none"
dupecheck
contains $statedir/output.html item-a-title item-b-title item-c-title

begin "hideduplicates id"
add "hideduplicates id"
dupecheck
contains $statedir/output.html item-a-title item-c-title
not_contains $statedir/output.html item-b-title

begin "hideduplicates link"
add "hideduplicates link"
dupecheck
contains $statedir/output.html item-b-title item-c-title
not_contains $statedir/output.html item-a-title

begin "hideduplicates link id"
add "hideduplicates link id"
dupecheck
contains $statedir/output.html item-c-title
not_contains $statedir/output.html item-a-title item-b-title

begin "allowduplicates"
add "feeddefaults allowduplicates=true"
add "hideduplicates link id"
dupecheck
contains $statedir/output.html item-a-title item-b-title item-c-title

begin "sortbyfeeddate false/true"
# Debian bug 651080.
for day in 01 02 03; do
	cat >$httpdir/$day.atom <<EOF
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>example-feed-title-${day}</title>
  <link href="http://example.org/${day}/"/>
  <updated>2013-01-${day}T18:00:00Z</updated>
  <author>
    <name>example-feed-author</name>
  </author>
  <id>http://example.org/${day}/feed-id</id>
  <entry>
    <title>example-item-title-${day}</title>
    <link href="http://example.org/${day}/item"/>
    <id>http://example.org/${day}/item-id</id>
    <updated>2013-01-${day}01T18:00:00Z</updated>
    <summary>ENTRY-${day}</summary>
  </entry>
</feed>
EOF
done
entries () {
	grep 'ENTRY' $statedir/output.html | sed 's,.*ENTRY-\(..\).*,\1,' | xargs -n10 echo
}
add "feed 0 $httpurl/03.atom"
runs -u
add "feed 0 $httpurl/02.atom"
runs -u
add "feed 0 $httpurl/01.atom"
add "sortbyfeeddate false"
runs -uw
equals "01 02 03" "$(entries)"
add "sortbyfeeddate true"
runs -w
equals "03 02 01" "$(entries)"

begin "default templates"
make_rss20 $httpdir/simple.rss
add "feed 0 $httpurl/simple.rss"
runs -uw
cp $statedir/output.html $statedir/output.html.orig
for template in page item feedlist feeditem; do
	run -s $template
	cp $outfile $statedir/$template
	run --show $template
	same $outfile $statedir/$template
	add "${template}template ${template}"
done
run -w
same $statedir/output.html.orig $statedir/output.html

begin "pre-2.15 template options"
make_rss20 $httpdir/simple.rss
add "feed 0 $httpurl/simple.rss"
runs -uw
cp $statedir/output.html $statedir/output.html.orig
run -t
cp $outfile $statedir/page
run --show-template
same $outfile $statedir/page
run -T
cp $outfile $statedir/item
run --show-itemtemplate
same $outfile $statedir/item
add "template page"
add "itemtemplate item"
run -w
same $statedir/output.html.orig $statedir/output.html
echo MAGIC1__items__ >$statedir/page
echo MAGIC2 >$statedir/item
run -uw
contains $statedir/output.html MAGIC1 MAGIC2

begin "item dates"
# Debian bug 651080.
run -s item
cp $outfile $statedir/item
echo "__date__" >>$statedir/item
make_atom10 $httpdir/feed.atom
add "feed 0 $httpurl/feed.atom"
add "sortbyfeeddate true"
add "timeformat HEADING-%m-%d-%H:%M"
add "datetimeformat ITEMDATE-%m-%d-%H:%M"
add "itemtemplate item"
runs -uw
contains $statedir/output.html "HEADING-01-01-18:00" "ITEMDATE-01-01-18:00"

begin "dates shown in local time"
echo "__date__" >$statedir/item
make_atom10 $httpdir/feed.atom
add "feed 0 $httpurl/feed.atom"
add "sortbyfeeddate true"
add "timeformat HEADING-%m-%d-%H:%M"
add "datetimeformat ITEMDATE-%m-%d-%H:%M"
add "itemtemplate item"
runs -u
export TZ="GMT+5"
runs -w
contains $statedir/output.html "HEADING-01-01-13:00" "ITEMDATE-01-01-13:00"
export TZ="$default_TZ"
runs -w
contains $statedir/output.html "HEADING-01-01-18:00" "ITEMDATE-01-01-18:00"

if [ -n "$ja_LC_ALL" ]; then
	begin "dates shown in Japanese"
	echo "__date__" >$statedir/item
	make_atom10 $httpdir/feed.atom
	add "feed 0 $httpurl/feed.atom"
	add "sortbyfeeddate true"
	add "timeformat HEADING-%A-%c"
	add "datetimeformat ITEMDATE-%A-%c"
	add "itemtemplate item"
	export LC_ALL="$ja_LC_ALL"
	runs -uw
	# Japanese for Tuesday, in Unicode.
	tue="&#28779;&#26332;&#26085;"
	contains $statedir/output.html "HEADING-$tue-" "ITEMDATE-$tue-"
	not_contains $statedir/output.html "Tuesday"
	export LC_ALL="$default_LC_ALL"
	runs -uw
	contains $statedir/output.html "HEADING-Tuesday" "ITEMDATE-Tuesday"
fi

begin "feed list templates"
make_rss20 $httpdir/0.rss
make_rss20 $httpdir/1.rss
make_rss20 $httpdir/2.rss
add "feed 0 $httpurl/0.rss"
add "feed 0 $httpurl/1.rss"
add "feed 0 $httpurl/2.rss"
run -s feedlist
cp $outfile $statedir/feedlist
echo "FEEDLIST" >>$statedir/feedlist
run -s feeditem
cp $outfile $statedir/feeditem
echo "FEEDITEM-__feed_url__" >>$statedir/feeditem
add "feedlisttemplate feedlist"
add "feeditemtemplate feeditem"
run -w
contains $statedir/output.html \
	FEEDLIST \
	FEEDITEM-$httpurl/0.rss FEEDITEM-$httpurl/1.rss FEEDITEM-$httpurl/2.rss

begin "showfeeds true/false"
make_atom10 $httpdir/simple.atom
add "feed 0 $httpurl/simple.atom"
runs -u
add "showfeeds true"
runs -w
contains $statedir/output.html $httpurl/simple.atom
add "showfeeds false"
runs -w
not_contains $statedir/output.html $httpurl/simple.atom

begin "userefresh true/false"
make_atom10 $httpdir/0.atom
make_atom10 $httpdir/1.atom
# It should pick the lowest of these and convert to seconds.
add "feed 1m $httpurl/0.atom"
add "feed 2m $httpurl/1.atom"
runs -u
add "userefresh true"
runs -w
contains $statedir/output.html 'http-equiv="Refresh" content="60"'
add "userefresh false"
runs -w
not_contains $statedir/output.html 'http-equiv="Refresh"'

begin "HTTP basic authentication"
make_rss20 $httpdir/private.rss
add "feed 0 $httpurl/auth-TestUser-TestPass/private.rss"
rune "401" -u
add "  user TestUser"
add "  password TestPass"
runs -u

# Generate a plugin to check that feedparser returned a particular HTTP status
# code.
checkstatus () {
	cat >$statedir/plugins/checkstatus.py <<EOF
import rawdoglib.plugins
def feed_fetched(rawdog, config, feed, p, error, nf):
    if $1 not in [e['status'] for e in p['rawdog_responses']]:
        print "didn't get HTTP $1 response"
rawdoglib.plugins.attach_hook("feed_fetched", feed_fetched)
EOF
}

begin "HTTP 304 not modified"
make_rss20 $httpdir/feed.rss
add "feed 0 $httpurl/feed.rss"
runs -u
checkstatus 304
runs -u

begin "HTTP 302 redirect to 304 not modified"
# feedparser issue 390.
make_rss20 $httpdir/new.rss
add "feed 0 $httpurl/302/new.rss"
runs -u
checkstatus 304
runs -u

begin "HTTP 302 temporary redirect"
make_rss20 $httpdir/new.rss
add "feed 0 $httpurl/302/new.rss"
runs -u

begin "HTTP 301 permanent redirect, changeconfig false"
make_rss20 $httpdir/new.rss
add "changeconfig false"
add "feed 0 $httpurl/301/new.rss"
rune "You should update its entry" -u
contains $statedir/config "$httpurl/301/new.rss"

begin "HTTP 301 permanent redirect, changeconfig true"
make_rss20 $httpdir/new.rss
add "changeconfig true"
add "feed 0 $httpurl/301/new.rss"
rune "has been updated automatically" -u
contains $statedir/config "$httpurl/new.rss"
runs -u

begin "HTTP 302 to 301"
# We should only update config if the first redirect is permanent.
make_rss20 $httpdir/feed.rss
add "changeconfig true"
add "feed 0 $httpurl/302/301/feed.rss"
runs -u
contains $statedir/config "$httpurl/302/301/feed.rss"

begin "HTTP 301 to 302"
make_rss20 $httpdir/feed.rss
add "changeconfig true"
add "feed 0 $httpurl/301/302/feed.rss"
rune "has been updated automatically" -u
contains $statedir/config "$httpurl/302/feed.rss"

begin "HTTP 301 to 301 to 302"
# rawdog should follow the 301s but not the 302 to find the new URL.
make_rss20 $httpdir/feed.rss
add "changeconfig true"
add "feed 0 $httpurl/301/301/302/feed.rss"
rune "has been updated automatically" -u
contains $statedir/config "$httpurl/302/feed.rss"

begin "HTTP 410 gone"
add "feed 0 $httpurl/410"
rune "You should remove it" -u

for state in false true; do
	other=$(if $state; then echo false; else echo true; fi)

	begin "converting from splitstate $state to splitstate $other"
	make_n 10 $httpdir/feed.rss
	add "splitstate $state"
	add "feed 1h $httpurl/feed.rss"
	runs -uw
	output_n 10
	rm $httpdir/feed.rss
	add "splitstate $other"
	runs -uw
	output_n 10
done

for state in false true; do
	begin "HTTP 301, moving items from existing feed, splitstate $state"
	make_range 1 5 $httpdir/old.rss
	add "splitstate $state"
	add "keepmin 20"
	add "changeconfig true"
	add "feed 0 $httpurl/old.rss"
	runs -uw
	rm $httpdir/old.rss
	make_range 6 10 $httpdir/new.rss
	echo >$httpdir/.rewrites "/old.rss /301/new.rss"
	rune "has been updated automatically" -uw
	# We should still have the original items at this point.
	output_range 1 10
	runs -uw
	output_range 1 10
done

begin "shorttag expansion"
# <br/> <br /> bug fixed 2006-01-07.
# <br/>/ has a workaround in feedparser for sgmllib.
add "tidyhtml false"
write_desc <<EOF
&lt;b&gt;0&lt;/b&gt;&lt;br/&gt;
&lt;b&gt;1&lt;/b&gt;&lt;br /&gt;
&lt;b&gt;2&lt;/b&gt;&lt;br/&gt;/
EOF
contains $statedir/output.html \
	"<b>0</b><br />" \
	"<b>1</b><br />" \
	"<b>2</b><br />/"

begin "broken processing instruction"
write_desc <<EOF
&lt;!doctype html!&gt;
EOF

begin "relative URIs resolved"
write_desc <<EOF
<![CDATA[<p>
<a href="rel-link">link</a>
<img src="rel-img">
</p>]]>
EOF
contains $statedir/output.html \
	"$httpurl/rel-link" \
	"$httpurl/rel-img"

begin "Javascript removed"
write_desc <<EOF
<![CDATA[<p>
<script type="text/javascript">
alert('Annoying1');
</script>
<span style="background: url(javascript:alert('Annoying2'))">span</a>
</p>]]>
EOF
not_contains $statedir/output.html "Annoying1" "Annoying2"

begin "stray ] in URL"
# This produced an "Invalid IPv6 URL" exception with feedparser r738.
write_desc <<EOF
<![CDATA[<p><a href="http://example.com/not-broken]">link</a></p>]]>
EOF
contains $statedir/output.html not-broken

if $knownbad; then
	begin "escaped slashes in URL"
	# feedparser issue 407: links with :// escaped get mangled (reported in
	# rawdog by Joseph Reagle).
	write_desc <<EOF
	<![CDATA[
	<a href="http:&#x2F;&#x2F;example.com&#x2F;0">link</a>
	<a href="https:&#x2F;&#x2F;example.com&#x2F;1">link</a>
	<a href="http&0x3A;&#x2F;&#x2F;example.com&#x2F;2">link</a>
	<a href="https&0x3A;&#x2F;&#x2F;example.com&#x2F;3">link</a>
	]]>
EOF
	contains $statedir/output.html \
		http://example.com/0 http://example.com/1 \
		http://example.com/2 http://example.com/3
fi

begin "add feed, actually a feed"
make_rss20 $httpdir/feed.rss
rune "Adding feed" -a $httpurl/feed.rss
contains "$statedir/config" $httpurl/feed.rss

begin "add feed, relative <link>"
# Debian bug 657206.
make_rss20 $httpdir/feed.rss
make_html_head $httpdir/page.html <<EOF
<link rel="alternate" type="application/rss+xml" title="RSS" href="feed.rss">
EOF
rune "Adding feed" -a $httpurl/page.html
contains "$statedir/config" $httpurl/feed.rss

begin "add feed, absolute <link>"
make_rss20 $httpdir/feed.rss
make_html_head $httpdir/page.html <<EOF
<link rel="alternate" type="application/rss+xml" title="RSS" href="$httpurl/feed.rss">
EOF
rune "Adding feed" -a $httpurl/page.html
contains "$statedir/config" $httpurl/feed.rss

begin "add feed, typical blog"
# Roughly what blogspot pages have.
make_atom10 $httpdir/posts
make_html_head $httpdir/page.html <<EOF
<link rel="alternate" type="application/atom+xml" title="My Blog - Atom" href="$httpurl/posts">
<link rel="alternate" type="application/atom+xml" title="My Blog - RSS" href="$httpurl/posts?alt=rss">
<link rel="service.post" type="application/atom+xml" title="My Blog - Atom" href="http://example.org/posts">
EOF
rune "Adding feed" -a $httpurl/page.html
contains "$statedir/config" $httpurl/posts
not_contains "$statedir/config" "alt=rss"

begin "add feed, avoid HTML <link>"
make_html $httpdir/dummy.html
make_html_head $httpdir/page.html <<EOF
<link rel="alternate" type="text/html" title="Something" href="$httpurl/dummy.html">
EOF
rune "Cannot find any feeds" -a $httpurl/page.html

begin "add feed, <a> with obvious URL"
make_rss20 $httpdir/foo.rss
make_html_body $httpdir/page.html <<EOF
<p>Here is our <a href="$httpurl/foo.rss">feed</a>!</p>
EOF
rune "Adding feed" -a $httpurl/page.html

if $knownbad; then
	begin "add feed, <a> with non-obvious URL"
	# ... as boingboing.net currently has (old feedfinder doesn't find
	# this; it finds /atom.xml by brute force).
	make_rss20 $httpdir/foo
	make_html_body $httpdir/page.html <<EOF
	<p>Here is our <a href="$httpurl/foo">RSS feed</a>!</p>
EOF
	rune "Adding feed" -a $httpurl/page.html
fi

if $knownbad; then
	# Old feedfinder could find this because it tried appending lots of
	# likely suffixes to URLs. However, this generally isn't needed
	# nowdays; most of the feeds that it could find that way have proper
	# <link> elements.
	begin "add feed, brute force"
	make_atom10 $httpdir/index.atom
	make_html $httpdir/page.html
	rune "Adding feed" -a $httpurl/page.html
fi

begin "add feed, no feeds to be found"
make_html $httpdir/page.html
rune "Cannot find any feeds" -a $httpurl/page.html

begin "add feed, nonsense in HTML"
# Debian bug 650776. This will provoke a HTMLParseError.
make_rss20 $httpdir/feed.rss
make_html_head $httpdir/page.html <<EOF
<link rel="alternate" type="application/rss+xml" title="RSS" href="feed.rss">
<![GARBAGE]]>
EOF
rune "Adding feed" -a $httpurl/page.html
contains "$statedir/config" $httpurl/feed.rss

begin "add feed, already present"
make_atom10 $httpdir/feed.atom
add "feed 3h $httpurl/feed.atom"
rune "already in the config file" -a $httpurl/feed.atom

begin "add feed, prefer Atom over RSS"
make_rss20 $httpdir/feed.rss
make_atom10 $httpdir/feed.atom
make_html_head $httpdir/page.html <<EOF
<link rel="alternate" type="application/rss+xml" title="RSS" href="feed.rss">
<link rel="alternate" type="application/atom+xml" title="Atom" href="feed.atom">
EOF
rune "Adding feed" -a $httpurl/page.html
contains "$statedir/config" $httpurl/feed.atom

begin "add feed, prefer entries over comments"
make_atom10 $httpdir/comments.atom
make_atom10 $httpdir/entries.atom
make_html_head $httpdir/page.html <<EOF
<link rel="alternate" type="application/atom+xml" title="Atom Comments" href="comments.atom">
<link rel="alternate" type="application/atom+xml" title="Atom" href="entries.atom">
EOF
rune "Adding feed" -a $httpurl/page.html
contains "$statedir/config" $httpurl/entries.atom

begin "add feed, keep page order"
make_atom10 $httpdir/0.atom
make_atom10 $httpdir/1.atom
make_html_head $httpdir/page.html <<EOF
<link rel="alternate" type="application/atom+xml" title="Atom" href="0.atom">
<link rel="alternate" type="application/atom+xml" title="Atom" href="1.atom">
EOF
rune "Adding feed" -a $httpurl/page.html
contains "$statedir/config" $httpurl/0.atom

begin "add feed, ignore broken link"
make_atom10 $httpdir/1.atom
make_html_head $httpdir/page.html <<EOF
<link rel="alternate" type="application/atom+xml" title="Atom" href="0.atom">
<link rel="alternate" type="application/atom+xml" title="Atom" href="1.atom">
EOF
rune "Adding feed" -a $httpurl/page.html
contains "$statedir/config" $httpurl/1.atom

begin "add feed, UTF-8 in attr"
# This problem showed up in orbitbooks.net's front page. The intent is fine,
# but it crashes Python 2.7's HTMLParser if it's not properly decoded.
make_atom10 $httpdir/feed.atom
make_html_head $httpdir/page.html <<EOF
<link rel="alternate" type="image/gif" title="ø&quot;" href="picture.gif">
<link rel="alternate" type="application/atom+xml" title="Atom" href="feed.atom">
EOF
rune "Adding feed" -a $httpurl/page.html
contains "$statedir/config" $httpurl/feed.atom

begin "remove feed"
add "feed 3h $httpurl/0.rss"
add "feed 3h $httpurl/1.rss"
add "feed 3h $httpurl/2.rss"
rune "Removing feed" -r $httpurl/1.rss
contains "$statedir/config" $httpurl/0.rss $httpurl/2.rss
not_contains "$statedir/config" $httpurl/1.rss

begin "remove feed with options"
add "feed 3h $httpurl/0.rss"
add "   define_foo 0a"
add "   define_foo 0b"
add "feed 3h $httpurl/1.rss"
add "   define_foo 1a"
add "   define_foo 1b"
add "feed 3h $httpurl/2.rss"
add "   define_foo 2a"
add "   define_foo 2b"
rune "Removing feed" -r $httpurl/1.rss
contains "$statedir/config" \
	$httpurl/0.rss "foo 0a" "foo 0b" \
	$httpurl/2.rss "foo 2a" "foo 2b"
not_contains "$statedir/config" \
	$httpurl/1.rss "foo 1a" "foo 1b"

begin "remove nonexistant feed"
add "feed 3h $httpurl/0.rss"
add "feed 3h $httpurl/1.rss"
add "feed 3h $httpurl/2.rss"
rune "not in the config file" -r $httpurl/3.rss

# Run the plugins test suite if it's there.
if [ -e rawdog-plugins/test-plugins ]; then
	. rawdog-plugins/test-plugins
fi
